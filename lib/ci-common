#!/usr/bin/env bash
# This file:
#
#  - Provide common functionalities for ci-* scripts.
#
# Usage (in other scripts before argument validation and runtime):
#
#  source "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/lib/ci-common"
#
# Based on a template by BASH3 Boilerplate v2.4.1
# http://bash3boilerplate.sh/#authors
#
# The MIT License (MIT)
# Copyright (c) 2013 Kevin van Zonneveld and contributors
# You are not obligated to bundle the LICENSE file with your b3bp projects as long
# as you leave these references intact in the header comments of your source files.

# shellcheck source=common
source "$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/common"

### Functions
##############################################################################

function setup() {
  local s
  s=$(exec_with_debug git stash)
  if [[ -n $s && $s != "No local changes to save" && $s != "没有要保存的本地修改"                                                                                                                         ]]; then
    info "The current working space is stashed and cleaned."
    __stashed=$(current_branch_name)
  fi
  trap "exit_ 3" SIGINT SIGTERM
}

function teardown() {
  __current_branch=$(current_branch_name)
  if is_branch_existing "${__starting_branch}" && [[ "${__current_branch}" != "${__starting_branch}" ]]; then
    exec_with_debug git checkout "${__starting_branch}"
    __current_branch="${__starting_branch}"
  fi
  if [[ -n "${__stashed}" ]]; then
    if [[ "${__stashed}" == "${__current_branch}" ]]; then
      info "Restore the working space by stash pop."
      exec_with_debug git stash pop
    else
      notice "There is a stash performed on branch \"${__stashed}\" earlier by ci." \
             "Please take care of it at your own risk."
    fi
  fi
}

function exit_() {
  teardown
  exit "${1:-0}"
}

function exit_with_error() {
  exit_code=$?
  error "$@"
  exit_ $exit_code
}

function is_git_repo() {
  git rev-parse --git-dir > /dev/null 2>&1
}

function current_branch_name() {
  local branch_name
  branch_name=$(git symbolic-ref -q HEAD)
  branch_name=${branch_name##refs/heads/}
  branch_name=${branch_name:-HEAD}
  echo "$branch_name"
}

function is_branch_existing() {
  if [[ -z $1 ]]; then
    return 1
  fi
  local branch_name
  branch_name=$(git branch --list "$1")
  [[ -n $branch_name ]]
}

function is_tag_existing() {
  git rev-parse "refs/tags/$1" > /dev/null 2>&1
}

function git_local_branches_to_prune() {
    git branch -r | awk '{print $1}' | grep -E -v -f /dev/fd/0 <(git branch -vv | grep "${REMOTE_ORIGIN}") | awk '{print $1}' || true
}

function is_version() {
  local version
  version=${1:-}
  [[ $version =~ ^(${PROJECT_VERSION_PREFIX})?[0-9]+\.[0-9]+\.[0-9]+$   ]]
}

function normalize_version() {
  local version
  version=${1:-}
  if [[ ${version} =~ ^${PROJECT_VERSION_PREFIX}.*$ ]]; then
    echo "${version}"
  else
    echo "${PROJECT_VERSION_PREFIX}${version}"
  fi
}

function version_bump() {
  local version
  local bump_method
  local version_fields
  local version_major
  local version_minor
  local version_patch
  bump_method=${1:-}
  version=${2:-}
  if [[ -z "${version}" ]]; then
    error "Script error: No version provided."
    exit_ 5
  fi
  if ! is_version "${version}"; then
    error "\"${version}\" is not a valid version."
    exit_ 1
  fi
  version="${version#${PROJECT_VERSION_PREFIX}}"
  IFS='.' read -ra version_fields <<< "${version}"
  version_major="${version_fields[0]}"
  version_minor="${version_fields[1]}"
  version_patch="${version_fields[2]}"
  if [[ ${bump_method} == "major" ]]; then
    version_major=$((version_major + 1))
    version_minor=0
    version_patch=0
  elif [[ ${bump_method} == "minor" ]]; then
    version_minor=$((version_minor + 1))
    version_patch=0
  elif [[ ${bump_method} == "patch" ]]; then
    version_patch=$((version_patch + 1))
  else
    error "Script error: Unknown version bump method: $bump_method."
    exit_ 5
  fi
  echo "${PROJECT_VERSION_PREFIX}${version_major}.${version_minor}.${version_patch}"
}

### Variable Definition
##############################################################################

__stashed=
__starting_branch=$(current_branch_name)

### Validation. Error out if the things required for your script are not present
##############################################################################

if ! which git >/dev/null 2>&1; then
  error "Command \"git\" is not found. Please install it first."
  exit 2
fi

if ! which hub >/dev/null 2>&1; then
  error "Command \"hub\" is not found. Please install it by following the instructions on https://hub.github.com/."
  exit 2
fi

if ! is_git_repo; then
  error "This is not a git repo."
  exit 2
fi
